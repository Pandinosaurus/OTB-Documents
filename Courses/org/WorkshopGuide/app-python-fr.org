** Utiliser les OTB Applications en Python                           :slides:
*** Objectifs et Données
**** Objectifs
     - Savoir configurer son environnement de travail pour utiliser les
       applications OTB en Python
     - Savoir configurer une application en Python (API)
     - Savoir chainer en mémoire des traitements OTB depuis Python
     - Savoir utiliser les passerelles entre OTB et NumPy.

**** Données
      Les données sont disponibles dans le répertoire ~Data/otb-python/~.

*** Déroulement
    Cette exercice consiste à mettre en oeuvre un script Python pour extraire
    les surfaces en eaux dans des images optiques Sentinel-2 au Pérou dans la
    région de /Laguna la nina/.

    #+attr_LATEX: :float t :width \textwidth
    [[file:Images/lluvias-peru.jpg]]


    (Image Twitter de @hombredeltiempo)

*** Rapide introduction aux applications OTB
    - Orfeo ToolBox est une librairie de traitements d'images de télédétection
    - Souvent nécessaire de combiner plusieurs algorithmes pour créer sa chaine
      de traitement
    - Besoin accès interfaces de plus haut niveau (paramètres, entrées/sorties, log...)
    - 1 application OTB = 1 fonctionnalité (segmentation, ortho-rectification,
      calcul raster...)
    - 1 application = 1 classe C++(/otb::Application/)
    - 1 application = 1 plugin
    - Possible de développer et distribuer ses propres applications

*** OTB applications en Python
    - Librairie Python *otbApplication*
    - 2 classes principales:
      - Registry: liste les applications disponibles
      - Application: API pour manipuler les paramètres d'une application
    - Exemple:
#+begin_src python
import otbApplication 
orth=otb.Registry.CreateApplication("OrthoRectification") 
#+end_src

*** Syntax 
    - Accesseurs
#+begin_src python
app.GetParametersKeys()
#+end_src
    - Mutateurs
#+begin_src python
app.SetParameterString("in", argv[1])
#+end_src
    - Comment on exécute une application?
      - Execute() -> câble le "pipeline OTB" 
      - ExecuteAndWriteOutput() -> câble le "pipeline OTB" et écrit les sorties

*** Sucre syntaxique
    - Au lieu de:
#+begin_src python
ExtractROI.SetParameterInt('startx', 140)
#+end_src

    - Utiliser plutôt: 
#+begin_src python
ExtractROI.STARTX=140
#+end_src
    - Lettres en capitales obligatoire pour le moment

*** Connexion en mémoire des applications
    - On utilise souvent 1 application dans une chaine plus large
    - Les opérations de lecture/écriture sont souvent couteuse spécialement en télédétection
    - Idée: connecter la sortie de app1 à l'entrée de app2
    - Syntaxe disponible en C++ et Python
    - Lié aux méchanismes de traitements au fil de l'eau(/streaming/) de l'OTB

*** Lien OTB/NumPy
    - Facilite l'utilisation de l'OTB dans un script Python
    - Méthodes à utiliser: GetImageFromNumpyArray() et SetImageFromNumpyArray() 
   
*** Liens utiles
    - [[https://www.orfeo-toolbox.org/CookBook/OTB-Applications.html][Introduction to OTB applications]]
    - [[https://www.orfeo-toolbox.org/CookBook/Applications.html][Application Reference Documentation]]
    - Application help: /otbcli\textunderscore{}XXX -help/
** Utiliser les OTB Applications en Python                             :guide:
*** Description                                                        :desc:
**** Résumé
     
     L'exercice suivant est une introduction à l'utilisation des applications
     OTB en Python.

     Cet exercice consiste à prototyper une chaine de traitements avec
     l'objectif d'extraire des surfaces en eaux à partir d'images Sentinel-2.

**** Pré-requis

     - Logiciels installés (Monteverdi et Orfeo ToolBox)
     - Python (2.7.X ou 3.5.X), avec NumPy et l'environnement OTB correctement
       configuré (aide: sourcer le fichier otbenv.profile sous Linux ou lancer otbenv.bat
       sous Windows). 
       *Test*: Lancer la commande Python "import otbApplication" pour vérifier
       son environnement 
     - Données (~Data/app-python~) 
     - Comprendre le méchanisme des OTB applications (voir exercice /stegano/) 

**** Objectifs

     - Configurer et lancer des applications OTB depuis Python
     - Utiliser la connexion en mémoire entre les applications
     - Utiliser des données satellites optiques Sentinel2 (niveau 2A) en entrée
     - Mettre en oeuvre une méthode simple d'extraction des surfaces en eau en
       utilisant l'indice NDVI
     - Evaluer les performances de détection à partir d'une carte de référence

*** Étapes                                                            :steps:

    Les données sont disponibles dans le dossier ~Data/app-python~, avec les
    sous-répertoires suivants: 
     - ~images~ contient 2 images Sentinel-2 (Niveau 2A) sur /Laguna de la Nina/ (Pérou)
     - ~ref~ contient des données de référence (masque d'occurrence de l'eau) au
       format raster.

    Ce répertoire contient également les scripts Python suivant:
    ~exercise1.py~ ... ~exercise5.py~

**** Introduction : Suivi des surfaces en eau dans la région de /Laguna de la Nina/(Pérou) 

     La zone d'intérêt utilisée dans l'exercice est Laguna de la Nina au Pérou
     ((-5.8101 lat, -80.7155 lon). En 2017, la région a subie de fortes
     inondations en raison du phénomène "El nino". L'objectif est de mettre en
     évidence ces changements à partir de plusieurs images satellites.

     Dans cette exercice nous utiliserons trois images Sentinel-2 (niveau 2A)
     (répertoire ~app-python/images~) acquises aux dates suivantes: 

|--------------|
|  2016-12-18  |
|  2017-04-07  |
|  2017-12-03  |
|--------------|

     1. Ouvrez les images composite_*.vrt dans Monteverdi. Elles correspondent
        au composition RGB pour chaque date. Qu'observe-t-on dans ces images?  
        Comment évolue les surfaces en eau? 

     *Note*: L'image compisite au format VRT a été crée avec l'utilitaire
     ~gdalbuildvrt~ pour cet exercice. Elle ne sont pas inclus dans les produits Sentinel-2.

**** Sentinel 2 - Niveau 2A

     L'un des objectifs de cet exercice est de traiter un produit Sentinel-2
     téléchargé depuis la plateforme [[https://theia.cnes.fr][Theia]]. Le niveau de produit /2A/ correspond
     à une image orthorectifiée en réflectance de surface (prise en compte des
     effets atmosphériques). Ce produit est obtenu
     par un traitement des produits de niveau /1C/ (orthorectifié en réflectance
     au dessus de l'atmosphère) réalisé par la méthode MAJA.

     Chaque produit Sentinel-2 contient plusieurs fichiers: 
         - SRE: image en réflectance de surface (SRE pour Surface REflectance)
           ont été corrigées corrigées des effets atmosphériques, y compris les effets d'environnement
         - FRE: (FRE pour Flat REflectance) ont, de plus, subi une correction
           supplémentaire qui prend en compte les effets des pentes
         - MTD: Métadonnées
         - QKL: vignette (image RGB basse résolution)
         - ATB:  variables atmosphériques (2 bandes):
                - 1ère bande: vapeur d'eau, il faut diviser les valeurs par 20 pour obtenir des $g.cm^2$ 
                - 2ème bande: épaisseur optique des aérosols, il faut diviser
                  les valeurs par 200 pour obtenir l'épaisseur optique. 
         - CLM: Masque de nuages (calculé par MAJA), image 1 bande codée sur 8 bits.
         - SAT: masque de pixels saturés
         
     Dans cette exercice, le masque d'eau sera calculé à partir des images SRE
     et FRE.

     Les produits SRE et FRE consistent en 13 fichiers, une par bande spectrale
     au format GeoTiff (.tif). Les bandes peuvent être à 10m ou 20m de
     résolution spatiale.

|----------------+------------+------------+------------+-------------------------------|
| Nom bande      | Id         | Longueur d'onde | Résolution | Utilisée dans l'exercice |
|----------------+------------+------------+------------+-------------------------------|
| Bleu           | B2         | 490 nm          | 10 m       | -                        |
| Vert           | B3         | 560 nm          | 10 m       | -                        |
| Rouge          | B4         | 665 nm          | 10 m       | Oui                      |
| PIR - 1        | B5         | 705 nm          | 20 m       | -                        | 
| PIR - 2        | B6         | 740 nm          | 20 m       | -                        | 
| PIR - 3        | B7         | 783 nm          | 20 m       | -                        |   
| PIR - Large    | B8         | 842 nm          | 10 m       | -                        |
| PIR - 4        | B8A        | 865 nm          | 20 m       | Oui                      |  
| MIR 1          | B11        | 1610 nm         | 20 m       | -                        |
| MIR 2          | B12        | 2190 nm         | 20 m       | -                        |  
|----------------+------------+-----------------+------------+--------------------------|

     For this exercise, only some bands will be used to obtain water extents maps: 
     Red (B4) and NIR - Narrow4 (B8A). Also, the Cloud Mask will be used. 

     *Note:* To reduce the dataset size, we have deleted all the bands not used and 
     replaced them with an empty file with the same name. 
    
     Let's play: 

     1. Since we are interested in ground reflectance images to calculate water 
        surfaces, what band kind of file would you use : SRE or FRE? 

     2. Look at the disk size of B3 and B11 files of one the datasets in 
        ~app-python/images/SENTINEL2A_*/~ Do all files have the same disk
        size? Why?

        *Note:* On the command line, launch the ~gdalinfo~ command on different band 
        files to check the pixel size and the number of pixels.
     
        *Note 2:* Make sure that OTB binary files ($otb-path/bin) is included 
        in your PATH environment variable.
 
     4. Look at /MASKS subfolder : there is a CLM file that contains a cloud
        mask. Do you think that this information might be interesting to 
        make better water detections? How? 

     5. Open in Monteverdi the B8A and B4 and check the values in a water surface.
        Which band has higher reflectance values on water surfaces? (Use the 20170407 date
        to have wider water surfaces)

**** Simple OTB application in Python : exercise1.py
    
     Take a look to the script: ~app-python/exercise1.py~. The aim of 
     this script is to launch the Superimpose application from OTB to resample 
     the B8A band (20m pixel size) to a new resolution. 
  
     At the beginning, there is an otbApplication import. In the otbApplication
     module, two main classes can be manipulated:

        - /Registry/, which provides access to the list of available applications, 
          and can create applications.
        - /Application/, the base class for all applications. This allows to 
          interact with an application instance created by the Registry

     1. In order to show the available applications, launch ~exercise1.py~ with 
        the command  : 
        #+BEGIN_EXAMPLE
        $ python exercise1.py
        #+END_EXAMPLE
        At the output you will see the list
        of available applications. Which line in the script allowed to show the 
        list of applications? This method is present in the Registry or in an Application
        module?

     On the second part of the script, we want to launch the Superimpose application
     to do the resampling of the B8A image (20m pixel size) using the image
     B4 (10m pixel size) as a reference.

     The script ~exercise1.py~ launches the Superimpose OTB application 
     as presented in the following scheme:

     #+ATTR_LATEX: :float t :width 0.8\textwidth
     [[file:Images/app-python-1.png]]
      
     *Note:* Superimpose may be configured to used different interpolations 
     (linear, bi-cubic or nearest neighbor)

     The necessary inputs and outputs of the [[https://www.orfeo-toolbox.org/CookBook/Applications/app_Superimpose.html][Superimpose application]] are
     described in the following table:

|---------------+------------------------+----------------|
| Parameter Key | Parameter Name         | Parameter Type |
|---------------+------------------------+----------------|
| inr           | Reference Input        | input image    | 
| inm           | The image to reproject | input image    | 
| out           | Output image           | output image   | 
     
     2. Open ~exercise1.py~ and complete the "FILL THE GAP 1". 
        You need to complete the path of ~app-python/images~ of your system.
     3. Open ~exercise1.py~ and complete the "FILL THE GAP 2".
        You need to initialize the Superimpose OTB application. See that the ~inr~
        ,~inm~ and ~out~ parameters are already set. 
     4. Launch ~exercise1.py~ the script with the command 
        python exercise1.py. How does the output file ~B8A_10m.tif~ look like?       
         
         
**** Chain OTB applications : exercise2.py

     In this part, the aim is to calculate an NDVI image and obtain a water mask by means
     of thresholding the NDVI value. We will launch different OTB applications
     in the same script to obtain the desired result.

     The script ~exercise2.py~ chains OTB applications as presented in the following scheme:
      #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-2.png]]

     Use the Superimpose and Bandmath applications to calculate the NDVI and
     the water map image 
     using Red band (B4) and NIR band (B8A) from the S2 product:
     1. Open ~exercise2.py~ and complete the "FILL THE GAP 1".
        You need to complete the path of ~app-python/images~ of your system.
     2. Open ~exercise2.py~ and complete the "FILL THE GAP" 2, 3 and 4.
        You need to :
            - configure the application1 "Superimpose" parameters : ~inr,imr,out~
            - configure the application2 "BandMath" parameters:  ~il,out,exp~
            - configure the application3 "BandMath" parameters:  ~il,out,exp~
        *Note:* Take a look to lines 23-30 to understand the filepath of each band image.
        Check also the online help of the applications if necessary.

     3. Launch ~exercise2.py~ script with the command: 
        #+BEGIN_EXAMPLE
        $ python exercise2.py
        #+END_EXAMPLE
        What are the resulting files? Check the results in Monteverdi.

**** Chain OTB applications in-memory: exercise3.py
     This exercise is equivalent to exercise2.py, but avoiding to write on intermediate
     files. The goal is to process the intermediary results using only RAM memory. 

     As a second improvement, the NDVI calculation is left to 
     the last step: NDVI and water mask are calculated at the same time.  
     In OTB terms, we perform just one BandMath calculation (instead of two).
     
     The script ~exercise3.py~ chains OTB applications as presented in the following scheme:
      #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-3.png]]

     In-memory connection: the output of app1 might be declared as input of
     app2 using an expression as: 
        - app2.SetParameterInputImage("in",app1.GetParameterOutputImage("out"))
          if the input of application2 is an Image(like in the Superimpose application)
        - app2.AddImageToParameterInputImageList("il",app1.GetParameterOutputImage("out"))
          if the input of application2 is an ImageList(like the BandMath application)
     
     Let's optimize our water mask calculator:
     1. Open ~exercise3.py~ and complete the "FILL THE GAP 1".
        You need to complete the path of ~app-python/data~ of your system.
     2. Open ~exercise3.py~ and complete the "FILL THE GAP 2" to declare the output 
        of application1 as input of application2.
     3. Open ~exercise3.py~ and complete the "FILL THE GAP 3" to set the BandMath expression
        that sets value 1 if ndvi value<0 and 0 if ndvi value>1
     4. Launch ~exercise3.py~ with the command: 
        #+BEGIN_EXAMPLE
        python exercise3.py
        #+END_EXAMPLE
        As you see in the code, the ApplicationX.ExecuteAndWriteOutput()
        has been changed to ApplicationX.Execute()
        in ~exercise3.py~. How does it affect the execution sequence?
     5. In Application1, the output parameter has been declared with a filename.
        Has it been written as a file after the execution? Why?
     6. At the generation of the NDVI mask(with two possible values: water(1) and land(0) 
        ), there is a line like : 
         appX.SetParameterOutputImagePixelType("out", otbApplication.ImagePixelType_ uint8)
         What is the purpose of this line? What would have happened without it?
        


**** Water detection chain with NoData management: exercise4.py

     There are some parts of the images that are covered by clouds. In this 
     exercise, we will use the CLD band in the S2 product to set NODATA regions.
     
     If a CLD pixel value is different of zero, that means that a cloud 
     has been detected in the pixel. The aim of this exercise is to use an special 
     value (255) in the final mask when clouds are present. 
     #+ATTR_LATEX: :float t :width 0.8\textwidth
     [[file:Images/app-python-4.png]]

     The script ~exercise4.py~ chains OTB applications as presented in the following scheme:
     #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-5.png]]

     At the end of the chain, an OTB application "ManageNoData" is used to set the NODATA value
     as 255 in the GeoTiff metadata.
     
     Let's do it:
     1. Open ~exercise4.py~ and complete the "FILL THE GAP 1".
        You need to complete the path of ~app-python/data~ of your system.
     2. Open ~exercise4.py~ and complete the "FILL THE GAP 2" to set the BandMath expression
        to set the 255 value where the clouds image is different to zero, and otherwise
        keep the NDVI mask image.
     3. Launch ~exercise4.py~ with the different dates as arguments:

            ~python exercise4.py SENTINEL2A_20161218-153729-222_L2A_T17MNP_D_V1-4~

            ~python exercise4.py SENTINEL2A_20170407-154054-255_L2A_T17MNP_D_V1-4~

            ~python exercise4.py SENTINEL2A_20171203-154308-349_L2A_T17MNP_D_V1-4~

        and you will obtain three different masks. Open them with monteverdi to check
        the water extent variations.
     4. Look at the 20161218 final water mask. What are the lines detected as water? 
         

**** Comparison with a reference : exercise5.py  
 
     The water masks obtained after February 2017 correspond to an special flood event 
     in the Laguna de la Nina. How often do we observe floods in this region? Let's try to 
     answer it. 
     
     The Global Surface Water(GSW) map, a water extent map based on optical images (Landsat satellite) over the
     last 30 years, can be helpful to understand how frequently water is detected in a given area. This product
     contains an occurrence layer that provides the ratio between "water found"
     occurrences and the number of valid observations in the
     last 30 years for each pixel. Hence, a pixel with occurrence value equal to 10 means 
     that water has been detected in 10% of valid observations.
     

     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-6.png]]

     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-7.png]]
     
     The Global Surface Water data are available for download in tiles 10°x10°
     on [[https://global-surface-water.appspot.com/download][Global Surface Water AppSpot website]].
 
     You will find the required dataset already downloaded in the folder: ~app-python/ref~

     For this exercise, we are going to compare the 3 water masks (20161218,
     20170407 and 20171203) produced in exercise 4 with the GSW product. 

     The method to follow for this exercise is:
         - Crop and resample the GSW occurrence layer(30m resolution) to match 
           with the water mask grid (10m resolution).
         - Apply a threshold on the GSW resampled product with different probabilities:
           10%, 20%, 30%, 50%, 75%, 95% to obtain different reference images
         - Compare the water extent masks of exercise 4 with each of the reference
           images issued from GSW. This comparison will help us to understand how often do
           we observe a water extent map along time.
     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-8.png]]

    
     Steps:
        1. Open the image ~ref/occurrence_90W_0N.tif~ in QGIS or Monteverdi.

           *WARNING*: Select "ignore" in the pop-up message for the overviews generation.

           What values do you observe around the coordinates lon: -80.6767, lat: -5.91. 
           Do you observe any zone with 90-100 occurrence?  What does it means: 
           permanent or rare waters?

        2. Our zone of study is just a portion of the ~ref/occurrence_90W_0N.tif~. The ~exercise5.py~ script
           will launch Superimpose and Bandmath OTB applications to obtain the GSW layer cropped, resampled 
           and thresholded at given value. To obtain the reference mask launch:

           #+BEGIN_EXAMPLE
               python exercise5.py 10
               python exercise5.py 20	
               python exercise5.py 30
               python exercise5.py 50
               python exercise5.py 75
               python exercise5.py 90
           #+END_EXAMPLE

        3. Now it's time to compare each of the water masks of exercise 4 (on 3 dates: 20161218,
           20170407 and 20171203) with each of the reference images.
           Check the following list of applications in the [[https://www.orfeo-toolbox.org/CookBook/Applications.html][OTB Applications reference documentation]], 
           and look the Learning section. Which application do you think that might be helpful to compare 
           two raster maps?  
           Use this application to calculate the reference mask that yields the best likelihood (Kappa index)
           for each of the 3 water masks.You may launch the otb application in the commandline: 
               otbcli-XXXXX -in XXXX -out XXXX -param1 XXXX          
        4. What would you conclude about the results? 


** OTB Applications on Python API                                 :solutions:
*** Introduction : Water monitoring in the Laguna de la Nina(Peru) event 
    1. Open in Monteverdi the composition_*.vrt file (RGB composition) of each 
       of the dates. What do you observe in these images?  
       How does the water extent change? 
        
       Solution : The color composition of each image of level 2 allows to see the regions as 
       seen by the naked eye and seen as we did not have any atmosphere. 
       The images show how this region goes over three phases: 
        - empty lagoon on December 2016
        - max extension of the flooded lagoon in April 2017
        - flooding lagoon decreasing its size. 


*** Sentinel 2 - Level 2A Format

    1. Since we are interested in ground reflectance images to calculate water 
       surfaces, what band kind of file would you use between SRE and FRE? 
        
       Solution : FRE images corrects the effects of the atmosphere, and hence,
       the physical properties of the ground are better described on the FRE image.

    2. Look at the disk size of B3 and B11 files of one the datasets in 
       ~app-python/images/SENTINEL2A_*/~ Do all files have the same disk
       size? Why?
 
       Solution : B3 and B11 have different resolutions. Higher resolution (smaller pixel size) for the same area
       involves a higher number of pixels to be described in the file, and hence, a bigger file size. 

    3. On the command line, launch the ~gdalinfo~ command on different band 
       files to check the pixel size, the number of pixels and the minimum 
       and maximum values. Do we have common minimum values between 
       different bands? Why?
     
       *Note:* Make sure that OTB binary files ($otb-path/bin) is included 
       in your PATH environment variable.

       Solution: Each band is independent from the others.
 
    4. Look at /MASKS subfolder : there is a CLM file that contains a cloud
       mask. Do you think that this information might be interesting to 
       make better water detections? How? 

       Solution : An image with clouds does not contain information about the ground.
       It is better to avoid the cloud areas by tagging them as NODATA regions, in order to 
       avoid false detections of water.

    5. Open in Monteverdi the B8A and B4 and check the values in a water surface.
       What is the reflectance behavior of these bands on water surfaces?

       Solution : On water regions, B4(RED) has higher reflectance values than B8A(NIR).


*** Simple OTB application in Python : exercise1.py
    
    1. In order to show the available applications, launch exercise1.py with 
       the command  : python exercise1.py. On the output you will see the list
       of available applications. Which line in the script allowed to show the 
       list of applications? This method is present in the Registry or in an Application
       module?

    2. Open ~exercise1.py~ and complete the "FILL THE GAP 1". 
       You need to complete the path of ~app-python/data~ of your system.
    3. Open ~exercise1.py~ and complete the "FILL THE GAP 2".
       You need to initialize the Superimpose OTB application. See that the ~inr~
       ,~inm~ and ~out~ parameters are already set. 
    4. Launch ~exercise1.py~ the script with the command 
       python exercise1.py. How does the output look like?       
         
         
*** Chain OTB applications : exercise2.py

    1. Open ~exercise2.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise2.py~ and complete the "FILL THE GAP" 2, 3 and 4.
       You need to :
           - configure the application1 "Superimpose" parameters : ~inr,imr,out~
           - configure the application2 "BandMath" parameters:  ~il,out,exp~
           - configure the application3 "BandMath" parameters:  ~il,out,exp~
    4. Launch ~exercise2.py~ the script with the command: python exercise2.py. What
       are the resulting files?

*** Chain OTB applications in-memory: exercise3.py
     
    1. Open ~exercise3.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise3.py~ and complete the "FILL THE GAP 2" to declare the output 
       of application1 as input of application2.
    3. Open ~exercise3.py~ and complete the "FILL THE GAP 3" to set the BandMath expression
       that sets value 1 if ndvi value<0 and 0 if ndvi value>1
    4. Launch ~exercise3.py~ with the command: python exercise3.py. 
       As you see in the code, the ApplicationX.ExecuteAndWriteOutput()
       has been changed to ApplicationX.Execute()
       in ~exercise3.py~. How does it affect to the execution sequence?
    5. In Application1, the output parameter has been declared with a filename.
       Has it been written as a file after the execution? Why?
    6. At the generation of the NDVI mask(with two possible values: water(1) and land(0) 
       ), there is a line like : 
        appX.SetParameterOutputImagePixelType("out", otbApplication.ImagePixelType_uint8)
        What is the purpose of this line? What would happened without it?

*** Water detection chain with NoData management: exercise4.py

    1. Open ~exercise4.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise4.py~ and complete the "FILL THE GAP 2" to set the BandMath expression
       to set the 255 value where the clouds image is different to zero, and otherwise
       keep the NDVI mask image.
    3. Launch ~exercise4.py~ with the different dates as arguments:

           ~python exercise4.py SENTINEL2A_20161218-153729-222_L2A_T17MNP_D_V1-4~

           ~python exercise4.py SENTINEL2A_20170407-154054-255_L2A_T17MNP_D_V1-4~

           ~python exercise4.py SENTINEL2A_20171203-154308-349_L2A_T17MNP_D_V1-4~

       and you will obtain three different masks. Open them with monteverdi to check
       the water extent variations.
    4. Look at the 20161218 final NDVI mask. What are the lines detected as water? 
         

*** Comparison with a reference 
 
    1. Open the image ~ref/occurrence_90W_0N.tif~ in QGIS or Monteverdi. What values do you observe
       around the coordinates lon: -80.6767, lat: -5.91. Do you observe any zone with 90-100 occurrence?
       What does it means: permanent or rare waters?
    2. Our zone of study is just an portion of the ~ref/occurrence_90W_0N.tif~. The ~exercise5.py~ script
       will launch Superimpose and Bandmath OTB applications to obtain the GSW layer cropped, resampled 
       and thresholded over a given value. To obtain the reference mask launch:
           python exercise5.py 10
           python exercise5.py 20	
           python exercise5.py 30
           python exercise5.py 50
           python exercise5.py 75
           python exercise5.py 90
    3. Now it's time to compare each of the water masks of exercise 4 (on 3 dates: 20161218,
       20170407 and 20171203) with each of the reference images.
       Check the following list of applications in www.orfeo-toolbox.org/CookBook/Applications.html, 
       and look the Learning section. Which application do you think that might be helpful to compare 
       two raster maps?  
       Use this application to calculate the reference mask that yields the best likelihood (Kappa index)
       for each of the 3 water masks.You may launch the otb application in the commandline: 
           otbcli-XXXXX -in XXXX -out XXXX -param1 XXXX          
    4. What would you conclude about the results?

