** Utiliser les OTB Applications en Python                           :slides:
*** Objectifs et Données
**** Objectifs
     - Savoir configurer son environnement de travail pour utiliser les
       applications OTB en Python
     - Savoir configurer une application en Python (API)
     - Savoir chainer en mémoire des traitements OTB depuis Python
     - Savoir utiliser les passerelles entre OTB et NumPy.

**** Données
      Les données sont disponibles dans le répertoire ~Data/otb-python/~.

*** Déroulement
    Cette exercice consiste à mettre en oeuvre un script Python pour extraire
    les surfaces en eaux dans des images optiques Sentinel-2 au Pérou dans la
    région de /Laguna la nina/.

    #+attr_LATEX: :float t :width \textwidth
    [[file:Images/lluvias-peru.jpg]]


    (Image Twitter de @hombredeltiempo)

*** Rapide introduction aux applications OTB
    - Orfeo ToolBox est une librairie de traitements d'images de télédétection
    - Souvent nécessaire de combiner plusieurs algorithmes pour créer sa chaine
      de traitement
    - Besoin accès interfaces de plus haut niveau (paramètres, entrées/sorties, log...)
    - 1 application OTB = 1 fonctionnalité (segmentation, ortho-rectification,
      calcul raster...)
    - 1 application = 1 classe C++(/otb::Application/)
    - 1 application = 1 plugin
    - Possible de développer et distribuer ses propres applications

*** OTB applications en Python
    - Librairie Python *otbApplication*
    - 2 classes principales:
      - Registry: liste les applications disponibles
      - Application: API pour manipuler les paramètres d'une application
    - Exemple:
#+begin_src python
import otbApplication 
orth=otb.Registry.CreateApplication("OrthoRectification") 
#+end_src

*** Syntax 
    - Accesseurs
#+begin_src python
app.GetParametersKeys()
#+end_src
    - Mutateurs
#+begin_src python
app.SetParameterString("in", argv[1])
#+end_src
    - Comment on exécute une application?
      - Execute() -> câble le "pipeline OTB" 
      - ExecuteAndWriteOutput() -> câble le "pipeline OTB" et écrit les sorties

*** Sucre syntaxique
    - Au lieu de:
#+begin_src python
ExtractROI.SetParameterInt('startx', 140)
#+end_src

    - Utiliser plutôt: 
#+begin_src python
ExtractROI.STARTX=140
#+end_src
    - Lettres en capitales obligatoire pour le moment

*** Connexion en mémoire des applications
    - On utilise souvent 1 application dans une chaine plus large
    - Les opérations de lecture/écriture sont souvent couteuse spécialement en télédétection
    - Idée: connecter la sortie de app1 à l'entrée de app2
    - Syntaxe disponible en C++ et Python
    - Lié aux méchanismes de traitements au fil de l'eau(/streaming/) de l'OTB

*** Lien OTB/NumPy
    - Facilite l'utilisation de l'OTB dans un script Python
    - Méthodes à utiliser: GetImageFromNumpyArray() et SetImageFromNumpyArray() 
   
*** Liens utiles
    - [[https://www.orfeo-toolbox.org/CookBook/OTB-Applications.html][Introduction to OTB applications]]
    - [[https://www.orfeo-toolbox.org/CookBook/Applications.html][Application Reference Documentation]]
    - Application help: /otbcli\textunderscore{}XXX -help/
** Utiliser les OTB Applications en Python                             :guide:
*** Description                                                        :desc:
**** Résumé
     
     L'exercice suivant est une introduction à l'utilisation des applications
     OTB en Python.

     Cet exercice consiste à prototyper une chaine de traitements avec
     l'objectif d'extraire des surfaces en eaux à partir d'images Sentinel-2.

**** Pré-requis

     - Logiciels installés (Monteverdi et Orfeo ToolBox)
     - Python (2.7.X ou 3.5.X), avec NumPy et l'environnement OTB correctement
       configuré (aide: sourcer le fichier otbenv.profile sous Linux ou lancer otbenv.bat
       sous Windows). 
       *Test*: Lancer la commande Python "import otbApplication" pour vérifier
       son environnement 
     - Données (~Data/app-python~) 
     - Comprendre le méchanisme des OTB applications (voir exercice /stegano/) 

**** Objectifs

     - Configurer et lancer des applications OTB depuis Python
     - Utiliser la connexion en mémoire entre les applications
     - Utiliser des données satellites optiques Sentinel2 (niveau 2A) en entrée
     - Mettre en oeuvre une méthode simple d'extraction des surfaces en eau en
       utilisant l'indice NDVI
     - Evaluer les performances de détection à partir d'une carte de référence

*** Étapes                                                            :steps:

    Les données sont disponibles dans le dossier ~Data/app-python~, avec les
    sous-répertoires suivants: 
     - ~images~ contient 2 images Sentinel-2 (Niveau 2A) sur /Laguna de la Nina/ (Pérou)
     - ~ref~ contient des données de référence (masque d'occurrence de l'eau) au
       format raster.

    Ce répertoire contient également les scripts Python suivant:
    ~exercise1.py~ ... ~exercise5.py~

**** Introduction : Suivi des surfaces en eau dans la région de /Laguna de la Nina/(Pérou) 

     La zone d'intérêt utilisée dans l'exercice est Laguna de la Nina au Pérou
     ((-5.8101 lat, -80.7155 lon). En 2017, la région a subie de fortes
     inondations en raison du phénomène "El nino". L'objectif est de mettre en
     évidence ces changements à partir de plusieurs images satellites.

     Dans cette exercice nous utiliserons trois images Sentinel-2 (niveau 2A)
     (répertoire ~app-python/images~) acquises aux dates suivantes: 

|--------------|
|  2016-12-18  |
|  2017-04-07  |
|  2017-12-03  |
|--------------|

     1. Ouvrez les images composite_*.vrt dans Monteverdi. Elles correspondent
        au composition RGB pour chaque date. Qu'observe-t-on dans ces images?  
        Comment évolue les surfaces en eau? 

     *Note*: L'image compisite au format VRT a été crée avec l'utilitaire
     ~gdalbuildvrt~ pour cet exercice. Elle ne sont pas inclus dans les produits Sentinel-2.

**** Sentinel 2 - Niveau 2A

     L'un des objectifs de cet exercice est de traiter un produit Sentinel-2
     téléchargé depuis la plateforme [[https://theia.cnes.fr][Theia]]. Le niveau de produit /2A/ correspond
     à une image orthorectifiée en réflectance de surface (prise en compte des
     effets atmosphériques). Ce produit est obtenu
     par un traitement des produits de niveau /1C/ (orthorectifié en réflectance
     au dessus de l'atmosphère) réalisé par la méthode MAJA.

     Chaque produit Sentinel-2 contient plusieurs fichiers: 
         - SRE: image en réflectance de surface (SRE pour Surface REflectance)
           ont été corrigées corrigées des effets atmosphériques, y compris les effets d'environnement
         - FRE: (FRE pour Flat REflectance) ont, de plus, subi une correction
           supplémentaire qui prend en compte les effets des pentes
         - MTD: Métadonnées
         - QKL: vignette (image RGB basse résolution)
         - ATB:  variables atmosphériques (2 bandes):
                - 1ère bande: vapeur d'eau, il faut diviser les valeurs par 20 pour obtenir des $g.cm^2$ 
                - 2ème bande: épaisseur optique des aérosols, il faut diviser
                  les valeurs par 200 pour obtenir l'épaisseur optique. 
         - CLM: Masque de nuages (calculé par MAJA), image 1 bande codée sur 8 bits.
         - SAT: masque de pixels saturés
         
     Dans cette exercice, le masque d'eau sera calculé à partir des images SRE
     et FRE.

     Les produits SRE et FRE consistent en 13 fichiers, une par bande spectrale
     au format GeoTiff (.tif). Les bandes peuvent être à 10m ou 20m de
     résolution spatiale.

|----------------+------------+------------+------------+-------------------------------|
| Nom des bandes | Id         | Longueur d'onde | Résolution | Utilisée dans l'exercice |
|----------------+------------+------------+------------+-------------------------------|
| Bleu           | B2         | 490 nm          | 10 m       | -                        |
| Vert           | B3         | 560 nm          | 10 m       | -                        |
| Rouge          | B4         | 665 nm          | 10 m       | Oui                      |
| PIR - 1        | B5         | 705 nm          | 20 m       | -                        | 
| PIR - 2        | B6         | 740 nm          | 20 m       | -                        | 
| PIR - 3        | B7         | 783 nm          | 20 m       | -                        |   
| PIR - Large    | B8         | 842 nm          | 10 m       | -                        |
| PIR - 4        | B8A        | 865 nm          | 20 m       | Oui                      |  
| MIR 1          | B11        | 1610 nm         | 20 m       | -                        |
| MIR 2          | B12        | 2190 nm         | 20 m       | -                        |  
|----------------+------------+-----------------+------------+--------------------------|

     Pour obtenir l'étendu en eau, les bandes suivantes seront utilisées: rouge
     (B4), PIR-4 (B8A). Nous utiliserons également le masque de nuages. 

     *Note:* Pour réduire la taille des données, nous avons supprimé les bandes
     non utilisées et elles sont remplacées par un fichier vide. 
    
     C'est parti: 

     1. Nous allons utilisé les images en réflectance de surface pour extraire
        les surfaces en eau, à votre avis quel produit plutôt utilisé: SRE ou FRE? 

     2. Comparez la taille sur le disque des produits B3 et B11 dans le
        répertoire ~app-python/images/SENTINEL2A_*/~. Est-ce que les fichiers
        font la même taille? Pourquoi?

        *Note:* En ligne de commande, utilisez la commande ~gdalinfo~ sur les
        différents fichiers pour afficher la taille et le nombre de pixels. 
     
        *Note 2:* Assurez-vous que les fichiers binaires OTB ($otb-path/bin) est
        est inclus dans vos variables d'environnement.
 
     4. Dans le répertoire /MASKS : il y a un fichier CLM qui contient le masque
        de nuages. Est-ce que ces informations sont pertinentes pour améliorer
        la détection d'eau? Comment?

     5. Ouvrez les bandes B8A et B4 dans Monteverdi et comparez les valeurs des
        pixels sur les surfaces en eau.
        Quelle bande a une réflectance plus forte sur les surfaces en eau?
        (Utilisez pluto l'image à la date du 07/04/2017 avec une étendue d'eau
        plus importante)

**** Une application OTB simple : exercise1.py
    
     Ouvrez le script: ~app-python/exercise1.py~. Le but de ce script est
     d'utiliser l'application Superimpose pour réechantillonner la bande B8A
     (résolution 20m). 
  
     Au début du script, il y a l'importation de la librarie
     otbApplication. Dans le module otbApplication, 2 classes sont disponibles: 

        - /Registry/, liste les applications disponibles et permet de charger
          des applications. 
        - /Application/, la classe de base pour toutes les applications. Elle
          permet d'intéragir avec une instance d'application créee par la classe
          /Registry/ 

     1. Pour lister la liste des applications, lancez ~exercise1.py~ avec la commande: 
        #+BEGIN_EXAMPLE
        $ python exercise1.py
        #+END_EXAMPLE
        La sortie afficher la liste des applications disponibles. Quelle ligne
        dans le script affiche la liste des applications? Cette méthode est
        disponible dans les modules Registry ou Application?

     Dans la deuxième partie du script, l'objectif est d'utilisé l'application
     Superimpose pour réechantilloner la bande B8A (20m de résolution) en
     utilisant la bande B4 (A0m de résolution) comme référence.

     Le script ~exercise1.py~ utilise l'application Superimpose comme présenté
     dans le schéma ci-dessous:

     #+ATTR_LATEX: :float t :width 0.8\textwidth
     [[file:Images/app-python-1.png]]
      
     *Note:* L'application Superimpose peut être configurée avec plusieurs
     interpolateurs (linéaire, bi-cubique ou plus proche voisin)

     Les entrées et sorties nécessaires pour [[https://www.orfeo-toolbox.org/CookBook/Applications/app_Superimpose.html][Superimpose application]] sont décrit
     dans le tableau ci-dessous:

|---------------+------------------------+--------------------|
| Clé paramètre | Nom du paramètre       | Type de paramètres |
|---------------+------------------------+--------------------|
| inr           | Image de référence     | input image        | 
| inm           | Image à reprojeter     | input image        | 
| out           | Image en sortie        | output image       | 
     
     2. Ouvrir le fichier ~exercise1.py~ et complète la ligne "FILL THE GAP 1". 
        Vous devez compléter le chemin de fichier ~app-python/images~ associé à
        votre système.
     3. Ouvrir ~exercise1.py~ et compléter la ligne "FILL THE GAP 2".
        Vous devez initialiser l'application Superimpose. Etudiez les paramètres ~inr~
        ,~inm~ et ~out~ déjà paramètrés. 
     4. Lancez le script ~exercise1.py~ avec la commande /python
        exercise1.py/. Commentez le contenu de la sortie ~B8A_10m.tif~?       
         
         
**** Chainage des applications OTB : exercise2.py

     Dans cette partie, le but est de calculer le NDVI de l'image et d'obtenir
     un masque d'eau par seuillage. Nous utiliserons différentes applications
     OTB avec le même script pour obtenir différents couches d'information.

     Le script Python ~exercise2.py~ chaîne des applications OTB suivant le
     schéma suivant: 
      #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-2.png]]

     Utilisez les applications Superimpose et BandMath pour calculer et le
     masque d'eau en utilisant les bandes Rouge (B4) et Proche Infrarouge (B8A)
     du produit Sentinel-2:
     1. Ouvrez ~exercise2.py~ et compléter la ligne "FILL THE GAP 1".
        Vous devez adapter le chemin ~app-python/images~ à votre système.
     2. Ouvrez ~exercise2.py~ et compléter le champ "FILL THE GAP" 2, 3 and 4.
        Vous devez :
            - configurer *application1* (Superimpose) et les paramètres : ~inr,imr,out~
            - configurer *application2* (BandMath) et les paramètres:  ~il,out,exp~
            - configurer *application3* (BandMath et les paramètres:  ~il,out,exp~
        *Note:* Etudiez les lignes 23-30 pour comprendre quel est le chemin de
        chaque bande.
        Vous pouvez aussi accèder à l'aide en ligne des applications si nécessaire.

     3. Lancez le script ~exercise2.py~ avec la commande: 
        #+BEGIN_EXAMPLE
        $ python exercise2.py
        #+END_EXAMPLE
        Quel est la sortie du script? Ouvrez le résultat dans Monteverdi.

**** Chainage en mémoire des applications OTB: exercise3.py
     Cet exercice est équivalent à /exercise2.py/, à la différence qu'on ne
     souhaite pas écrire les fichiers intermédiaires sur disque. L'objectif est
     de traiter toute la chaine de traitements en mémoire (RAM).  

     Une seconde amélioration est laissé pour la dernière étape du tutorial, qui
     consiste à calculer le NDVI et le seuillage en une seule étape. 
     En terme OTB, cela consiste à appliquer 1 BandMath (au lieu de 2).
     
     Le script ~exercise3.py~ enchaine les applications OTB suivant le schéma suivant:
      #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-3.png]]

     Connexion en mémoire: la sortie de /app1/ doit être déclaré comme entrée de
     l'application /app2/ en utilisant la syntaxe suivante: 
        - app2.SetParameterInputImage("in",app1.GetParameterOutputImage("out"))
          si l'entrée de /application2/ est une image (comme pour l'application Superimpose)
        - app2.AddImageToParameterInputImageList("il",app1.GetParameterOutputImage("out"))
          si l'entrée de /application2/ est une liste d'image (comme pour l'application BandMath)
     
     Optimisons le calcul du masque d'eau:
     1. Ouvrir ~exercise3.py~ et compléter la ligne "FILL THE GAP 1".
        Vous devez adapter le chemin ~app-python/data~ à votre système.
     2. Ouvrir ~exercise3.py~ et compléter "FILL THE GAP 2" pour déclarer la
        sortie de /application1/ comme entrée de /application2/.
     3. Ouvrir ~exercise3.py~ et compléter "FILL THE GAP 3" pour adapter
        l'expression en entrée de l'application BandMath pour obtenir que: "la
        valeur 1 est donnée si ndvi<0 et la valeur 0 si ndvi>1"
     4. Lancez ~exercise3.py~ avec la commande suivante: 
        #+BEGIN_EXAMPLE
        python exercise3.py
        #+END_EXAMPLE
        Vous pouvez remarquer que dans le script,
        l'appelApplicationX.ExecuteAndWriteOutput() a été changé par
        ApplicationX.Execute() dans ~exercise3.py~. Comment cela modifie la
        séquence des exécutions?
     5. Dans Application1, les paramètres de sortie ont été déclarés avec un nom
        de fichier.
        Est-ce que le fichier a été écrit sur le disque après l'exécution? Pourquoi?
     6. Au moment de la génération du masque NDVI (avec 2 valeurs possibles:
        eau(1) et land(0)), il y a la ligne suivante: 
         appX.SetParameterOutputImagePixelType("out", otbApplication.ImagePixelType_ uint8)
         Quel est le but de cette ligne? Qu'est-ce qui se passe si on supprime cette ligne?

**** Détection et gestion des /nodata/: exercise4.py

     Il y a certaines parties de l'image couverte par des nuages. Dans cet
     exercice, nous utiliserons la bande CLD du produit Sentinel-2 pour
     spécifier la valeur du NODATA.
     
     Si un pixel du masque CLD est différent de zéro, cela signifie qu'un nuage
     a été detecté par l'algorithme MAJA. Le but de cet exercice est de
     spécifier une valeur spéciale (255) dans le masque final quand un nuage est
     présent. 
     #+ATTR_LATEX: :float t :width 0.8\textwidth
     [[file:Images/app-python-4.png]]

     Le script ~exercise4.py~ chaîne des applications OTB comme présenté dans le
     schéma suivant:
     #+ATTR_LATEX: :float t :width 1\textwidth
     [[file:Images/app-python-5.png]]

     A la fin du script, l'application *ManageNoData* est utilisée pour
     spécifier la valeur de NODATA à 255 dans les métadonnées du fichier GeoTiff.
     
     On y va:
     1. Ouvrir ~exercise4.py~ et compléter le champ "FILL THE GAP 1".
        Vous devez adapter le chemin ~app-python/data~ à votre système.
     2. Ouvrir ~exercise4.py~ and complete the "FILL THE GAP 2" to set the BandMath expression
        to set the 255 value where the clouds image is different to zero, and otherwise
        keep the NDVI mask image.
     3. Launch ~exercise4.py~ with the different dates as arguments:

            ~python exercise4.py SENTINEL2A_20161218-153729-222_L2A_T17MNP_D_V1-4~

            ~python exercise4.py SENTINEL2A_20170407-154054-255_L2A_T17MNP_D_V1-4~

            ~python exercise4.py SENTINEL2A_20171203-154308-349_L2A_T17MNP_D_V1-4~

        and you will obtain three different masks. Open them with monteverdi to check
        the water extent variations.
     4. Look at the 20161218 final water mask. What are the lines detected as water? 
         

**** Comparison with a reference : exercise5.py  
 
     The water masks obtained after February 2017 correspond to an special flood event 
     in the Laguna de la Nina. How often do we observe floods in this region? Let's try to 
     answer it. 
     
     The Global Surface Water(GSW) map, a water extent map based on optical images (Landsat satellite) over the
     last 30 years, can be helpful to understand how frequently water is detected in a given area. This product
     contains an occurrence layer that provides the ratio between "water found"
     occurrences and the number of valid observations in the
     last 30 years for each pixel. Hence, a pixel with occurrence value equal to 10 means 
     that water has been detected in 10% of valid observations.
     

     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-6.png]]

     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-7.png]]
     
     The Global Surface Water data are available for download in tiles 10°x10°
     on [[https://global-surface-water.appspot.com/download][Global Surface Water AppSpot website]].
 
     You will find the required dataset already downloaded in the folder: ~app-python/ref~

     For this exercise, we are going to compare the 3 water masks (20161218,
     20170407 and 20171203) produced in exercise 4 with the GSW product. 

     The method to follow for this exercise is:
         - Crop and resample the GSW occurrence layer(30m resolution) to match 
           with the water mask grid (10m resolution).
         - Apply a threshold on the GSW resampled product with different probabilities:
           10%, 20%, 30%, 50%, 75%, 95% to obtain different reference images
         - Compare the water extent masks of exercise 4 with each of the reference
           images issued from GSW. This comparison will help us to understand how often do
           we observe a water extent map along time.
     #+ATTR_LATEX: :float t :width 0.7\textwidth
     [[file:Images/app-python-8.png]]

    
     Steps:
        1. Open the image ~ref/occurrence_90W_0N.tif~ in QGIS or Monteverdi.

           *WARNING*: Select "ignore" in the pop-up message for the overviews generation.

           What values do you observe around the coordinates lon: -80.6767, lat: -5.91. 
           Do you observe any zone with 90-100 occurrence?  What does it means: 
           permanent or rare waters?

        2. Our zone of study is just a portion of the ~ref/occurrence_90W_0N.tif~. The ~exercise5.py~ script
           will launch Superimpose and Bandmath OTB applications to obtain the GSW layer cropped, resampled 
           and thresholded at given value. To obtain the reference mask launch:

           #+BEGIN_EXAMPLE
               python exercise5.py 10
               python exercise5.py 20	
               python exercise5.py 30
               python exercise5.py 50
               python exercise5.py 75
               python exercise5.py 90
           #+END_EXAMPLE

        3. Now it's time to compare each of the water masks of exercise 4 (on 3 dates: 20161218,
           20170407 and 20171203) with each of the reference images.
           Check the following list of applications in the [[https://www.orfeo-toolbox.org/CookBook/Applications.html][OTB Applications reference documentation]], 
           and look the Learning section. Which application do you think that might be helpful to compare 
           two raster maps?  
           Use this application to calculate the reference mask that yields the best likelihood (Kappa index)
           for each of the 3 water masks.You may launch the otb application in the commandline: 
               otbcli-XXXXX -in XXXX -out XXXX -param1 XXXX          
        4. What would you conclude about the results? 


** OTB Applications on Python API                                 :solutions:
*** Introduction : Water monitoring in the Laguna de la Nina(Peru) event 
    1. Open in Monteverdi the composition_*.vrt file (RGB composition) of each 
       of the dates. What do you observe in these images?  
       How does the water extent change? 
        
       Solution : The color composition of each image of level 2 allows to see the regions as 
       seen by the naked eye and seen as we did not have any atmosphere. 
       The images show how this region goes over three phases: 
        - empty lagoon on December 2016
        - max extension of the flooded lagoon in April 2017
        - flooding lagoon decreasing its size. 


*** Sentinel 2 - Level 2A Format

    1. Since we are interested in ground reflectance images to calculate water 
       surfaces, what band kind of file would you use between SRE and FRE? 
        
       Solution : FRE images corrects the effects of the atmosphere, and hence,
       the physical properties of the ground are better described on the FRE image.

    2. Look at the disk size of B3 and B11 files of one the datasets in 
       ~app-python/images/SENTINEL2A_*/~ Do all files have the same disk
       size? Why?
 
       Solution : B3 and B11 have different resolutions. Higher resolution (smaller pixel size) for the same area
       involves a higher number of pixels to be described in the file, and hence, a bigger file size. 

    3. On the command line, launch the ~gdalinfo~ command on different band 
       files to check the pixel size, the number of pixels and the minimum 
       and maximum values. Do we have common minimum values between 
       different bands? Why?
     
       *Note:* Make sure that OTB binary files ($otb-path/bin) is included 
       in your PATH environment variable.

       Solution: Each band is independent from the others.
 
    4. Look at /MASKS subfolder : there is a CLM file that contains a cloud
       mask. Do you think that this information might be interesting to 
       make better water detections? How? 

       Solution : An image with clouds does not contain information about the ground.
       It is better to avoid the cloud areas by tagging them as NODATA regions, in order to 
       avoid false detections of water.

    5. Open in Monteverdi the B8A and B4 and check the values in a water surface.
       What is the reflectance behavior of these bands on water surfaces?

       Solution : On water regions, B4(RED) has higher reflectance values than B8A(NIR).


*** Simple OTB application in Python : exercise1.py
    
    1. In order to show the available applications, launch exercise1.py with 
       the command  : python exercise1.py. On the output you will see the list
       of available applications. Which line in the script allowed to show the 
       list of applications? This method is present in the Registry or in an Application
       module?

    2. Open ~exercise1.py~ and complete the "FILL THE GAP 1". 
       You need to complete the path of ~app-python/data~ of your system.
    3. Open ~exercise1.py~ and complete the "FILL THE GAP 2".
       You need to initialize the Superimpose OTB application. See that the ~inr~
       ,~inm~ and ~out~ parameters are already set. 
    4. Launch ~exercise1.py~ the script with the command 
       python exercise1.py. How does the output look like?       
         
         
*** Chain OTB applications : exercise2.py

    1. Open ~exercise2.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise2.py~ and complete the "FILL THE GAP" 2, 3 and 4.
       You need to :
           - configure the application1 "Superimpose" parameters : ~inr,imr,out~
           - configure the application2 "BandMath" parameters:  ~il,out,exp~
           - configure the application3 "BandMath" parameters:  ~il,out,exp~
    4. Launch ~exercise2.py~ the script with the command: python exercise2.py. What
       are the resulting files?

*** Chain OTB applications in-memory: exercise3.py
     
    1. Open ~exercise3.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise3.py~ and complete the "FILL THE GAP 2" to declare the output 
       of application1 as input of application2.
    3. Open ~exercise3.py~ and complete the "FILL THE GAP 3" to set the BandMath expression
       that sets value 1 if ndvi value<0 and 0 if ndvi value>1
    4. Launch ~exercise3.py~ with the command: python exercise3.py. 
       As you see in the code, the ApplicationX.ExecuteAndWriteOutput()
       has been changed to ApplicationX.Execute()
       in ~exercise3.py~. How does it affect to the execution sequence?
    5. In Application1, the output parameter has been declared with a filename.
       Has it been written as a file after the execution? Why?
    6. At the generation of the NDVI mask(with two possible values: water(1) and land(0) 
       ), there is a line like : 
        appX.SetParameterOutputImagePixelType("out", otbApplication.ImagePixelType_uint8)
        What is the purpose of this line? What would happened without it?

*** Water detection chain with NoData management: exercise4.py

    1. Open ~exercise4.py~ and complete the "FILL THE GAP 1".
       You need to complete the path of ~app-python/data~ of your system.
    2. Open ~exercise4.py~ and complete the "FILL THE GAP 2" to set the BandMath expression
       to set the 255 value where the clouds image is different to zero, and otherwise
       keep the NDVI mask image.
    3. Launch ~exercise4.py~ with the different dates as arguments:

           ~python exercise4.py SENTINEL2A_20161218-153729-222_L2A_T17MNP_D_V1-4~

           ~python exercise4.py SENTINEL2A_20170407-154054-255_L2A_T17MNP_D_V1-4~

           ~python exercise4.py SENTINEL2A_20171203-154308-349_L2A_T17MNP_D_V1-4~

       and you will obtain three different masks. Open them with monteverdi to check
       the water extent variations.
    4. Look at the 20161218 final NDVI mask. What are the lines detected as water? 
         

*** Comparison with a reference 
 
    1. Open the image ~ref/occurrence_90W_0N.tif~ in QGIS or Monteverdi. What values do you observe
       around the coordinates lon: -80.6767, lat: -5.91. Do you observe any zone with 90-100 occurrence?
       What does it means: permanent or rare waters?
    2. Our zone of study is just an portion of the ~ref/occurrence_90W_0N.tif~. The ~exercise5.py~ script
       will launch Superimpose and Bandmath OTB applications to obtain the GSW layer cropped, resampled 
       and thresholded over a given value. To obtain the reference mask launch:
           python exercise5.py 10
           python exercise5.py 20	
           python exercise5.py 30
           python exercise5.py 50
           python exercise5.py 75
           python exercise5.py 90
    3. Now it's time to compare each of the water masks of exercise 4 (on 3 dates: 20161218,
       20170407 and 20171203) with each of the reference images.
       Check the following list of applications in www.orfeo-toolbox.org/CookBook/Applications.html, 
       and look the Learning section. Which application do you think that might be helpful to compare 
       two raster maps?  
       Use this application to calculate the reference mask that yields the best likelihood (Kappa index)
       for each of the 3 water masks.You may launch the otb application in the commandline: 
           otbcli-XXXXX -in XXXX -out XXXX -param1 XXXX          
    4. What would you conclude about the results?

